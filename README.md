# Job-Interview
##1. 迅雷2014C++研发笔试卷C
* **有关 #include \<stdio.h\> 和 #include "stdio.h" 的区别；**

<>引用的是编译器的类库路径里面的头文件，""引用的是你程序目录的相对路径中的头文件。假如你编译器定义的自带头文件引用在C:\Keil\c51\INC\下面，则#include<stdio.h>引用的就是C:\Keil\c51\INC\stdio.h这个头文件，不管你的项目在什么目录里，C:\Keil\c51\INC\stdio.h这个路径就定下来了。一般是引用自带的一些头文件：stdio.h、conio.h、string.h、stdlib.h等等之类的。

假如你的项目目录是在D:\Projects\tmp\，则#include "my.h" 引用的就是D:\Projects\tmp\my.h这个头文件。一般是用来引用自己写的一些头文件，如果使用""，它是会先在你项目的当前目录查找是否有对应头文件。如果没有，它还是会在对应的引用目录里面查找对应的头文件。意思就是，使用#include "stdio.h"如果你项目目录里面，没有stdio.h这个头文件，它还是会定位到C:\Keil\c51\INC\stdio.h这个头文件的。

**总结：**面试的时候这样回答就可以了：

<>引用的是编译器的类库路径里面的头文件;

""引用的是你程序目录的相对路径中的头文件，在程序目录的相对路径中找不到该头文件时会继续在类库路径里搜寻该头文件。 


* **在C++中，sizeof运算符，.成员运算符，.\*成员指针运算符，::作用域解析运算符以及?:条件运算符不能被重载；**


* **不能作为重载函数的调用的依据是：函数类型。可以的是：参数个数、参数类型和函数名称（返回类型）；**

**引用传递和指针传递还可以用是否加const来重载。**对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载搜索。

* **建立派生类对象时,3种构造函数分别是a(基类的构造函数)、b(成员对象的构造函数)、c(派生类的构造函数)这3种构造函数的调用顺序为: abc;**


* **如果友元函数重载一个运算符时，其参数表中没有任何参数则说明该运算符是：重载错误；**

* **拷贝构造函数的特点；**

拷贝函数和构造函数没有返回值； 拷贝构造函数的参数可以使一个或多个，但左起第一个必须是类的引用对象； 若类定义中没有声明拷贝构造函数，则编译器会自动生成一个缺省的拷贝构造函数，但是不会是该类的保护成员； 通过拷贝函数可以将另一个对象作为对象的初值。

* **在C++中，函数的重载取决于函数的参数列表。同名的函数，参数列表不一样则函数不一样。参数列表一样，返回类型不一样不代表函数被重载；**


* **有一幢100层高的大楼，给你两个完全相同的玻璃围棋子。假设从某一层开始，丢下玻璃棋子就会破碎。那么怎么利用手中的两颗棋子，用一种什么样的最优策略，知道这个临界的层高呢？ ;**

第一种策略：最简单的想法，利用手头的一颗围棋子从第一层开始逐层往下扔，遍历楼层。最好的情况是第一层就碎了，一次找出临界层高；最差的情况是到了第一百层才碎了，用了一百次才发现临界层高。 

第二种策略：由于手头不止一颗围棋子，而是两颗，所以可以利用一颗作为“探子”，用二分的思想进行探查。例如先在第五十层扔一次，如果没有碎，可以在七十五层再扔一次，如果这时候棋子碎了，则可以用手头的另一颗棋子从五十层开始逐层往下扔，最多二十五次会找出临界的层高；而如果第一次在五十层扔下碎了，则从第一层开始逐层往下扔，这时候最多扔五十次即可找出临界的层高，尽管这时候扔的情况看起来和第一种策略扔的次数一样，但意义不同，因为这次我们是明确知道了最多只会到达五十层而非一百层。

第三种策略：首先,为了保证成功，两颗棋子不能全碎。那么经过计算，第一次应该在16层尝试。如棋子碎则从1-15层继续尝试。这样最多尝试16次可以得到结果。如16层棋子未碎，则第二次应该在16+16-1=31层尝试。这样可以保证最多尝试次数仍然为16次。往下类似，这样得到最终结果是: 第一颗棋子应该依次在16,31,45,58,70,81,91这七层尝试。如在其中某层碎了则继续用第2颗在相邻两次尝试楼层中间继续尝试，这样最多只需要16次尝试可以确定此临界值。



* **用c++写一个函数，如Foo(const char \*str)，打印出str的全排列，如abc的全排列：abc, acb, bca, dac, cab,cba ；**

```C++
#include "iostream"
using namespace std;

void permutation(char * Str, char * pBegin){

	if (*pBegin == '\0')
		cout << Str << endl;
	else{

		for (char * i = pBegin; i != '\0'; i++){

			swap(*pBegin, *i);
			permutation(Str, pBegin + 1);
			swap(*pBegin, *i);

		}

	}

}


int main(){

	char * str = new char(10);
	str = "abc";
	permutation(str, str);

	return 0;
}


```